# SnakeGame
## 4. Custom Multiplay with Unity(2022.02.04 ~ 2022.02.16)
### 개발 환경
- Windows 10
- Unity 2020.3.26f1
- 10.3.31-MariaDB-0+deb10u1 Debian 10

### 사용 언어
- C#
- JavaScript (node.js)

### 테스트 환경
- PC (Windows 10)
- X4, V30 (Android 9)

### 개발 순서
1. [x] Client Networking (C#)
2. [x] Server Networking (node.js)
3. [x] Snake 동기화
    1. [x] 머리 동기화
    2. [x] 꼬리 개수 동기화
4. [x] Apple 동기화
    1. [x] Apple 위치 동기화
    2. [x] Snake가 Apple 먹었는지 판단 후 재배치
    3. [x] Apple 먹었으면 Snake 꼬리 증가
    4. [x] Apple 서버에서 관리하도록 수정
5. [x] 패배 조건 추가
6. [x] 승리 조건 추가
7. [x] 동시 종료
8. [x] DB
   1. [x] Login UI 구현
   2. [x] DB에 User 정보 기록
   3. [x] 신규 User 판단 및 생성
   4. [x] 승/패 저장
   5. [x] 최근 승/패 확인
9. [x] 재시작 구현

### 고민했던 점
- **동시 발생 처리**
  - 초기 생각 : Apple을 양쪽 client에서 먹고 각자 MySnake와 충돌시에만 정보를 server로 보내 반대 client에 반영시키면 된다고 생각했다. 동시에 먹었을 때 발생하는 문제에 대해 생각하지 못했다. 
  - 문제점 : 동시에 먹었을때 처리를 결정하는 부분이 필요하다.
  - 해결 : server에서 Apple의 충돌을 최종 결정하도록 구현했다. client에서 동시에 먹었다고 하더라도 network 속도의 차이와 node.js의 event loop에 의해 처리 순서가 결정된다. 먼저 들어온 충돌을 처리하는 도중에 다른 충돌 처리 요청이 들어온다면 무시되도록 구현했다.
- **동시 발생 테스트**
  - 초기 생각 : client에서 특정 시간이 지난 다음 frame에서 요청을 server로 보내서 테스트
  - 문제점 : client간의 frame이 동기화되어있지 않기 때문에 오차가 큰 문제가 있다.
  - 해결 : 1. 많은 요청을 보낸 후 같은 시간에 보내진 정보를 확인하여 테스트, 2. 다른 test 툴(ex. JMetter)을 활용하여 multi thread로 최소한의 오차로 테스트 해보기
  - 동시에 발생하는 일을 처리해야하는 경우, 동시라는 것을 명확하게 정의하는게 중요해 보인다. 완벽한 동시 발생은 컴퓨터 내에서 없기 때문에 얼마만큼의 오차까지 동시로 볼 것인가를 정하는 것이 중요하다. networrk 통신이 있는 경우 어느 시점을 기준으로 할 것인지도 명확히 해야 한다.
- **application level protocol**
  - 초기 생각 : 이 부분에 대해서 많은 고민을 하지 않고 단순히 string 전송으로 통신했다.
  - 문제점 : server와 client가 주고 받는 내용이 많아질수록 코드의 복잡도가 높아지고 관리하기 어려워졌다.
  - 해결 : 통신에 필요한 내용과 구조를 정의해 놓고 그것을 바탕으로 데이터 변환을 순차적으로 처리했다. 단순 string으로만 통신하는 것이 아니라 json을 활용하여 좀 더 확인하기 쉽게 만들었다.
- **Unity 비동기 처리**
  - 초기 생각 : 단순하게 network 통신 때문에 게임이 block되면 안된다고 생각해서 비동기 통신으로 구현하고 이것으로 인해 발생할 문제에 대해서는 깊게 생각해보지 않았다.
  - 문제점 : 비동기 통신 후 callback에서 GameObject에 영향을 주는 처리를 했더니 main thread 처리와 겹치는 경우 문제가 발생했다.
  - 해결 : 비동기 통신 후 GameObject에 영향을 주는 작업들은 main thread에서 처리하도록 수정했다. 작은 게임에서는 이정도의 처리만으로도 괜찮을지 모르지만 주고 받는 데이터가 엄청 많아지는 경우에는 최적화를 위해 처리 순서나 방법을 깊게 고민해야 할것 같다.
- **전체적인 구조 그림 그리기**
  - 초기 생각 : 전체적인 그림을 생각해 보지 않고 당장의 다음 구현상의 이슈에만 집중했다.
  - 문제점 : 당장의 구현에 맞는 코드를 작성하다보니 전체적으로는 유지보수가 쉽지 않은 코드가 되었다.
  - 해결 : 많은 경험이 필요한 문제라고 생각한다. 하지만 이것을 의식하고 개발하는것과 아닌것의 차이는 클 것 같다. 또한 전체적인 life cycle도 처음에 고려해야할 사항이다.

****
## 3. Multiplay with Unity(2022.01.24 ~ 2022.02.03)
### 개발 환경
- Windows 10
- Unity 2020.3.26f1

### 사용 언어
- C#

### 테스트 환경
- PC (Windows 10)
- X4 (Android 9)

### 개발 순서
1. [ ] ~~Mirror~~
   1. [x] 머리 방향 동기화
   2. [x] 꼬리 그리기 동기화
2. [x] PUN2 (Photon Unity Networking)
   1. [x] Snake 구현
      1. [x] 머리 이동 구현 (터치로 이동)
      2. [x] 머리 이동 방향으로 회전
      3. [x] 꼬리 구현
   2. [x] Apple(먹이) 구현
      1. [x] Apple 랜덤한 위치에 생성
      2. [x] Snake가 Apple 먹었는지 판단 후 재배치
      3. [x] Apple 먹었으면 Snake 꼬리 증가
   3. [x] 패배 조건 추가
   4. [x] 승리 조건 추가
   5. [x] 동시 종료

### 고민했던 점
- **동기화**
  - 초기 생각 : third party package를 사용하면 잘 될 것이라고 막연하게 생각했다.
  - 문제점 : Mirror를 활용해서 개발했을때 동기화가 너무 맞지 않았다. 내부 동작 원리를 몰랐기 때문에 단기간내에 해결할 수 없었다.
  - 해결 : Photon을 활용해서 좀 더 동기화가 잘 되도록 구현했다. 하지만 완벽하게 싱크가 맞지는 않았다. MultiPlay에 대한 좀 더 자세한 이해가 필요한 것 같다. 다음 미션을 진행하면서 동기화에 대해서 더 깊게 알아봐야겠다.
- **third party package 선택**
  - 초기 생각 : https://blog.unity.com/technology/choosing-the-right-netcode-for-your-game 이 글만 보고 Mirror가 적합하다고 생각해서 선택했다.
  - 문제점 : 자료가 비교적 많지 않아 개발하는데 막히는 부분을 해결하기 쉽지 않았다. 직접 코드를 확인해봐야 했기 때문에 시간이 오래 걸렸다.
  - 해결 : 성능이나 가격에 대한 부분도 중요하지만 개발 기간과 자료의 양도 고려해서 좀 더 신중한 선택이 필요해 보인다.

### 다음 개발에서 생각해볼 부분
- QuickStart나 tutorial을 진행할때 단순히 기능의 동작만 확인하지 말고 원리를 생각하자
- 구글링전에 docs부터 확인
- 개발 진행 상황을 좀 더 구체적으로 공유
- Server와 Client를 어떤 방식으로 구성할 것인가?
- Position과 Rotation의 동기화를 어떻게 구현할 것인가?
- 통신 방식은 어떤 것을 사용할 것인가?
- RPC, RaiseEvent 등을 어떨게 구현할 것인가?

****
## 2. Unity2D (2022.01.17 ~ 2022.01.21)
### 개발 환경
- Windows 10
- Unity 2020.3.26f1

### 사용 언어
- C#

### 테스트 환경
- PC (Windows 10)
- X4 (Android 9)
- iPhone 13 (iOS 15.0)

### 개발 순서
1. [x] Snake 구현
   1. [x] 머리 이동 구현 (터치로 이동)
   2. [x] 머리 이동 방향으로 회전
   3. [x] 꼬리 구현
2. [x] Apple(먹이) 구현
   1. [X] Apple 랜덤한 위치에 생성
   2. [x] Snake가 Apple 먹었는지 판단 후 재배치
   3. [x] Apple 먹었으면 Snake 꼬리 증가
3. [x] 배경 그리기
4. [x] 종료 조건 판단
   1. [x] 벽에 부딪힌 경우
5. [x] 시작 메뉴 및 재시작 기능 구현

6. [x] Snake 머리 방향 좌우에 맞게 조정
7. [x] GameObject 재사용 가능하게 수정

### 고민했던 점
- **GameObject Component 추가**
  - 초기 생각 : GameObject, Component를 editor에서 생성한 것과 script에서 생성한 것에 대한 구분이 모호했다.
  - 문제점 : script에서 GameObject와 Component들을 활용할 때 햇갈리고 중복되는 코드들이 많았다.
  - 해결 : 전체 클래스 구조를 그려보면서 editor에서 생성한 것과 script에서 생성한 것의 구분을 명확히 했다. visualize가 잘 되어있는 editor활용시 editor에서 생성된 객체가 script에서 생성한 객체의 차이를 명확히 해야겠다.
- **Tirgger Callback Method 추가**
  - 초기 생각 : 당연히 같은 Tirgger Callback Method(ex. OnTriggerEnter2D())는 하나만 등록된다고 생각했다.
  - 문제점 : Trigger Callback Method 추가 방식이 OnTriggerEnter2D()가 작성된 AppleTrigger(MonoBehaviour)클래스 자체를 Component로 추가했기 때문에 재시작할때마다 Callback Method가 추가로 등록되었다. 코드의 구조에 문제점이 있긴 했지만 선입견 때문에 문제점을 찾기 어려웠다.
  - 해결 : 한번만 추가되도록 수정했다. 메서드 단위가 아니라 GameObject와 Component의 관계를 잘 생각해야겠다.
- **GameObject 재사용**
  - 초기 생각 : 재시작 할때마다 모든 Object 생성 후 종료시 Destory메서드를 활용하여 제거했다.
  - 문제점 : 간단한 게임이었기 때문에 문제는 없었지만 재사용 가능한 GameOject의 경우 재사용하는것이 좋다고 생각했다.
  - 해결 : GameObject pool을 만들고 Active 상태를 변경하는 방식으로 수정했다.
- **이동하는 이미지**
  - 초기 생각 : Cocos에서 개발할때 Snake의 머리의 상하좌우 구분이 없었기 때문에 머리이미지의 회전이나 반전을 개발전에 고려하지 않았다.
  - 문제점 : 방향 전환에 따른 머리 이미지의 회전, 반전이 필요했다. 구현시에 회전 각도를 0 ~ 360으로 생각했는데 -180 ~ 180이었다.([Quaternion과 Euler angle](https://killu.tistory.com/12))
  - 해결 : 이동 방향에 대한 백터 정보는 이미 있었기 때문에 계산을 통해 각도를 구하고 각도를 바탕으로 이미지를 회전, 반전시켰다.

### 다음 개발에서 생각해볼 부분
- 개발 초기에 간단하게 빌드를 해보고 개발
- 디바이스의 차이 생각해보면서 개발
- Snake와 Apple 재사용 가능하도록 수정
- Unity가 멀티플레이 지원방식이 HLAPI -> Netcode로 바뀐 이유
- git branch 나눠서 작업
- Unity test 방식 찾아보기
- .gitignore 프로젝트마다 적용하기
  
****
## 1. Cocos Creator (2022.01.10 ~ 2022.01.14)
### 개발 환경
- Windows 10
- Cocos creator 3.4
### 사용 언어
- TypeScript
### 테스트 환경
- web-mobile(chrome, iPhone)
### 개발 순서
1. [ ] Snake(사용자) 만들기
   1. [x] 노드 생성
   2. [x] 이동 스크립트 작성 (머리)
   3. [x] 이동 스크립트 작성 (꼬리)
   4. [ ] ~~그래픽 적용~~
2. [x] GameManager 만들기
   1. [x] Apple(먹이) 랜덤한 위치에 생성
   2. [x] Snake가 Apple을 먹었는지 판단 후 Apple 재배치
   3. [x] Apple 먹었으면 Snake 꼬리 증가
   4. [x] 종료 조건 판단하기
      1. [x] 자기 몸에 부딪힌 경우
      2. [x] 벽에 부딪힌 경우 경우
   5. [x] 시작 메뉴 및 재시작 기능
3. [x] 점수 표시하기

4. [x] 이동 방식 변경 (방향키-> 터치)

### 고민했던 점
- **꼬리 그리는 방식**
   - 초기 생각: 머리 위치를 queue형태로 저장하고 저장된 위치 정보로 꼬리 그리기
   - 문제점 : 너무 짧고 일정하지 않은 delta time 때문에 update() 메서드 호출시마다 머리의 위치를 저장 할 수 없었다.
   - 해결 : 일정 시간 단위(머리 크기만큼 이동할 시간)로 머리 위치를 저장하고 그 중간 위치는 deltaTime을 활용해 거리 비율을 맞춰 그렸다.
- **충돌 감지**
  - 초기 생각 : 좌표 일치를 통해 충돌 판단
  - 문제점 : deltaTime이 짧고 소수점이 있는 좌표계를 활용하는 경우 정확한 충돌 판단이 쉽지 않다.
  - 해결 : 임시 방편으로 오브젝트간의 거리 차이를 이용해 대략적으로 충돌을 판단했다. Collider를 활용하면 더 정확한 충돌을 감지 할 수 있을 것 같다.
- **게임 내 오브젝트들의 좌표와 터치 이벤트 좌표의 차이**
   - 초기 생각 : 단순하게 좌표의 차이를 활용해 방향만 찾으면 쉽게 구현할 수 있다고 생각했다.
   - 문제점 : 터치 이벤트의 좌표와 내부 오브젝트들의 좌표의 동작 방식 자체가 달랐다.
   - 해결 : https://discuss.cocos2d-x.org/t/understanding-the-principles-of-the-coordinate-system/54108

### 다음 개발에서 생각해볼 부분
   - 처음부터 게임의 LifeCycle을 생각하기
   - 어떤 디바이스에서 플레이할지 생각하고 조작법 정하기
   - 언어에서 지원하는 자료구조 구현체 사용시 문서 읽어보기
   - 자주 변경이 필요한 객체(ex. Vec3) 사용시 참조 주의
   - Collider를 활용한 충돌 감지
   - 꼬리 그리기 방식 개선
   - 장애물(다른 Snake, 단순 장애물) 등 게임적인 요소 추가
   - 그래픽 개선
